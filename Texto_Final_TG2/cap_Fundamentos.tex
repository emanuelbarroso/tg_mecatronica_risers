%TCIDATA{LaTeXparent=0,0,relatorio.tex}
\chapter{Fundamentos\label{chap:FundamentacaoMatematica}}

\resumodocapitulo{Este capítulo apresenta equações básicas do sistema que se deseja validar, explica a redução modal utilizada a técnica de controle em malha fechada. Também são apresentadas informações sobre a bancada laboratorial e sobre a programação do CLP.}

\section{Modelagem\label{modelagem}}
\subsection{Equação Governantes}

Estruturas submarinas tais como os \textit{risers} são esbeltas e tem um alto módulo de cisalhamento. Portanto, a simplificação de Euler-Bernoulli para vigas é utilizada para propósitos de modelagem. O deslocamento de interesse é o horizontal e o \textit{riser} está sob a ação de forças hidrodinâmicas externas e de tração. A equação diferencial parcial para a variável deslocamento, $\Upsilon$, é dada por \begin{align}
	m_s \frac{\partial^2 \Upsilon}{\partial t^2} &= -E J	\frac{\partial^4 \Upsilon}{\partial z^4} + \frac{\partial}{\partial z}\left(T(z) \frac{\partial \Upsilon}{\partial z}\right) + F_n(z,t)\label{equacaoMorison},
\end{align} na qual $m_s$ é a densidade linear do tubo, $E$ é o módulo de Young e $J$ é o segundo momento de inércia do \textit{riser}. $T(z)$ descreve as forças de tração ao longo do comprimento do \textit{riser}. $F_n(z,t)$ é a força resultante externa --- força linear, unidade N/m \cite{fabricioIFAC}. 

No caso do problema em escala laboratorial que foi trabalhado, o tubo é representado por um barbante e daqui em diante serão discutidas e apresentadas as variáveis necessárias para se trabalhar com esse problema: \begin{itemize}
	\item $m_s$ é a massa linear do barbante (densidade linear, kg/m);
	\item $E$ é o módulo de Young do barbante e ele é desconhecido;
	\item $J$ é o segundo momento de área e representa a resistência do barbante à flexão. O barbante não apresenta tal resistência, daí $J=0$;
	\item $T(z)$ é a força de tração e é dada por \[T(z) = \left(m_b+z m_s\right)g,\] sendo $m_b$ a massa da bolinha (kg), $m_s = m_{\textrm{barbante,kg}}/L$, sendo $L$ o comprimento do barbante, $z$ a posição vertical a partir do carrinho e $g$ é a força da gravidade.
\end{itemize}


As únicas forças externas atuando no \textit{riser} são hidrodinâmicas, exceto nas extremidades do topo e do fundo, nas quais forças de reação seguem condições de contorno. A equação de Morison descreve a força externa resultante: \begin{align}
	F_n(z,t) &= -m_{fbar} \frac{\partial^2 \Upsilon}{\partial t^2} - \mu \left|\frac{\partial \Upsilon}{\partial t}\right|\frac{\partial \Upsilon}{\partial t}\label{forceN},
\end{align} na qual $\mu$ é o coeficiente de arrasto (unidade 1/s) e $m_{fbar}$ é a massa do fluido adicionado, que será posteriormente pormenorizada. Fazendo $m = m_s + m_{fbar}$ e substituindo a Equação \ref{forceN} na \ref{equacaoMorison}, obtém-se: \begin{align}
	\frac{\partial^2 \Upsilon}{\partial t^2} &= -\frac{EJ}{m}\frac{\partial^4 \Upsilon}{\partial z^4} + \frac{\partial}{\partial z}\left(\frac{T(z)}{m}\frac{\partial \Upsilon}{\partial z}\right) - \frac{\mu}{m}\left|\frac{\partial \Upsilon}{\partial t}\right|\frac{\partial \Upsilon}{\partial t}
\end{align}

Em relação à massa do fluido adicionado, $m_{fbar}$ é dada por \begin{align}
	m_{fbar} &=  2 \pi r_{bar}^2 \rho_{\mathrm{ar}}\nonumber\\
	&= 0.00770\;\mathrm{g/m}.
\end{align} 

\paragraph{} Já que $m_{fbar} \ll m_s$ conforme a Tabela \ref{constanteBarbante}, consideraremos $m = m_s$ nos cálculos. Em relação à massa $m_{fb}$ do fluido adicionado ao redor da bolinha de isopor, ela é dada por\begin{align}
	m_{fb} &= 1.2 V_{b} \rho_{\mathrm{ar}}\nonumber\\
	&= 1.2 \left(\frac{4}{3}\pi r_b^3\right)\rho_{\mathrm{ar}}\nonumber\\
	&= 0.0220\;\textrm{g},
\end{align} de onde se pode observar que $m_{fb} \ll m_{b}$. Assim,  os cálculos consideraram $m' \approx m_b$.

\begin{table}[!ht]
	\centering
	\begin{tabular}{|l|c|c|c|}
		\hline
		\textbf{Significado} & \textbf{Símbolo} & \textbf{Valor} & \textbf{Unidade}\\ \hline \hline
		Massa & $m_{bar}$ & 0.492 & g\\ \hline
		Comprimento & $L$ & 0.82 & m \\ \hline
		Massa linear & $m_s$ & 0.6 & g/m\\ \hline
		Raio & $r_{bar}$ & 1 & mm\\ \hline
		Densidade & $\rho_{bar}$ & 191 & kg/m$^3$\\ \hline
	\end{tabular}
	\caption{Constantes do barbante\label{constanteBarbante}}
\end{table}

\begin{table}[!ht]
	\centering
	\begin{tabular}{|l|c|c|c|}
		\hline
		\textbf{Significado} & \textbf{Símbolo} & \textbf{Valor} & \textbf{Unidade}\\ \hline \hline
		Massa & $m_{b}$ & 0.492 & g\\ \hline
		Raio & $r_{b}$ & 15.3 & mm\\ \hline
		Coeficiente de inércia & $C_m$ & 1.2 & - \\ \hline
		Coeficiente de arrasto & $C_d$ & 0.6 & - \\ \hline
		Volume & $V_b$ & $\frac{4}{3}\pi r_b^3$ & $\textrm{m}^3$ \\ \hline
		Área da seção transversal & $A_b$ & $\pi r_b^2$ & m$^2$\\ \hline
	\end{tabular}
	\caption{Constantes da bolinha de isopor\label{constanteIsopor}}
\end{table}

%Para o presente trabalho, apenas o resultado do modelamento para malha aberta foi fornecido e utilizado. Para trabalhos futuros, as equações de controle serão desenvolvidas de acordo com as exigências do projeto.

\paragraph{} Um ponto importante de se notar é que o barbante pesa mais do que o isopor, o que faz com que a tração não seja principalmente devida pela bolinha, mas sim pelo barbante. Neste caso, não se utiliza um valor médio para $T(z)$ como em \cite{fabricioIFAC}, mas ainda se pode usar um valor médio para as constantes $\tau$ e $\tau'$, que substituem o termo $\frac{\mu}{m}\left|\frac{\partial \Upsilon}{\partial t}\right|$ para o barbante e para a bolinha, respectivamente. Essas constantes são definidas de acordo com a trajetória prevista, uma vez que a velocidade média depende dessa trajetória. Já levando em conta um valor médio para $\left|\frac{\partial \Upsilon}{\partial t}\right|$, tem-se \begin{align}
	\frac{\partial^2 \Upsilon}{\partial t^2} &= -\frac{EJ}{m}\frac{\partial^4 \Upsilon}{\partial z^4} + \frac{\partial}{\partial z}\left(\frac{T(z)}{m}\frac{\partial \Upsilon}{\partial z}\right) - \tau\frac{\partial \Upsilon}{\partial t}\label{EquacaoComTau}
	\end{align}

\paragraph{} Antes de se prosseguir para a discretização e obtenção das matrizes em espaço de estados, é importante pensar nas condições de contorno. No topo, $z=L$, tem-se $\Upsilon(L,t)=u(t)$, ou seja, o carrinho se move conforme uma trajetória $u(t)$ definida. Neste mesmo ponto, $\frac{\partial\Upsilon}{\partial z}(L,t) = 0$. Para a ponta na qual a carga está situada, $z=0$, tem-se $\frac{\partial\Upsilon}{\partial z}(0,t) = \frac{F_L}{T}$, sendo $F_L$ a força aplicada pela ponta do riser na carga.

\subsection{Discretização}
O objetivo desta seção é representar a Equação \ref{EquacaoComTau} em um espaço de estados finito discreto.  Para isso, aplica-se o método de diferenças finitas na coordenada $z$ de maneira a se aproximar a EDP governante em um número finito de EDOs. No espaço discreto, a equação do $k$-ésimo elemento é dada por \begin{align}
	\frac{d^2\Upsilon_k}{dt^2} &= -\frac{EJ}{m l^4}\left(\Upsilon_{k-2} - 4\Upsilon_{k-1}+6\Upsilon_{k}-4\Upsilon_{k+1}+\Upsilon_{k+2}\right)\nonumber\\
	&+ \frac{T_0+mg(k-1)l}{m l^2}\left(\Upsilon_{k-1}-2\Upsilon_{k} + \Upsilon_{k+1}\right)+g\frac{-\Upsilon_{k-1}+\Upsilon_{k+1}}{2l}-\tau\frac{d\Upsilon_k}{dt},
\end{align} sendo $N$ o número de pontos de discretização e $l$ a distância entre dois pontos vizinhos ($l = L/N$).

\paragraph{} Deve-se notar que $k\in \mathbb{N}:2\le k \le N-1$, pois um dos extremos é a bolinha e a equação do pêndulo rege seu movimento, enquanto que na outra ponta se aplica uma condição de contorno. O que aconteceria quando $k=2$ e se precisasse de $\Upsilon_{k-2}$? Para o presente experimento, $J=0$ e esse problema não ocorre. Caso se façam testes com um valor de $J\neq 0$, tem-se de resolver esse problema primeiro. Uma solução seria utilizar diferenças finitas unilaterais para esses pontos próximos à fronteira.

\paragraph{} Para simplificar, definem-se as constantes \begin{align}
	a &= -\frac{EJ}{m l^4}\\
	b_k &= \frac{T_0 + mg(k-1)l}{m l^2},\; k\ge 2\\
	c &= \frac{g}{2l}\\
	d_k &= b_k - c,\; k\ge 2\\
	e_k &= b_k + c,\; k\ge 2
\end{align}

\paragraph{} Uma estratégia para se analisar como as matrizes do espaço de estados do sistema ficarão é escolher um número de pontos $N$ pequeno e escrever todas as equações. Observa-se que $a=0$ para o barbante, pois $J=0$, como apresentado anteriormente, o que simplifica os cálculos.

\paragraph{} Para o caso $N=6$, por exemplo, tem-se \begin{align}
\mathbf{x} &= \left(\Upsilon_1\;\Upsilon_2\;\Upsilon_3\;\Upsilon_4\;\Upsilon_5\;\Upsilon_6\;\dot{\Upsilon}_1\;\dot{\Upsilon}_2\;\dot{\Upsilon}_3\;\dot{\Upsilon}_4\;\dot{\Upsilon}_5\;\dot{\Upsilon}_6\right)^T 	\\
u &= \Upsilon(L,t) = \Upsilon_7\label{ufor6}\\
y &= \Upsilon(0,t) = \Upsilon_1\label{yfor6}
 \end{align} e as equações são \begin{align}
 	\ddot{\Upsilon}_2 &=  b_2\left(\Upsilon_{1}-2\Upsilon_{2} + \Upsilon_{3}\right)+c(-\Upsilon_1 + \Upsilon_3)-\tau \dot{\Upsilon}_2\nonumber \\
 	&= d_2\Upsilon_1 - 2b_2 \Upsilon_2 + e_2\Upsilon_3 - \tau \dot{\Upsilon}_2 \label{upsilon2}\\
 	\ddot{\Upsilon}_3 &=  b_3\left(\Upsilon_{2}-2\Upsilon_{3} + \Upsilon_{4}\right)+c(-\Upsilon_2 + \Upsilon_4)-\tau \dot{\Upsilon}_3\nonumber \\
 	&= d_3\Upsilon_2 - 2b_3 \Upsilon_3 + e_3\Upsilon_4 - \tau \dot{\Upsilon}_3\\
 	\ddot{\Upsilon}_4 &=  b_4\left(\Upsilon_{3}-2\Upsilon_{4} + \Upsilon_{5}\right)+c(-\Upsilon_3 + \Upsilon_5)-\tau \dot{\Upsilon}_4 \nonumber\\
 	&= d_4\Upsilon_3 - 2b_4 \Upsilon_4 + e_4\Upsilon_5 - \tau \dot{\Upsilon}_4\\
 	\ddot{\Upsilon}_5 &=  b_5\left(\Upsilon_{4}-2\Upsilon_{5} + \Upsilon_{6}\right)+c(-\Upsilon_4 + \Upsilon_6)-\tau \dot{\Upsilon}_5\nonumber\\
 	&= d_5\Upsilon_4 - 2b_5 \Upsilon_5 + e_5\Upsilon_6 - \tau \dot{\Upsilon}_5\\
 	\ddot{\Upsilon}_6 &=  b_6\left(\Upsilon_{5}-2\Upsilon_{6} + u\right)+c(-\Upsilon_5 + u)-\tau \dot{\Upsilon}_6\nonumber\\
 	&= d_6\Upsilon_5 - 2b_6 \Upsilon_6 + e_6 u - \tau \dot{\Upsilon}_6 \label{upsilon6}
 \end{align}

\paragraph{} A equação para a posição da carga $\Upsilon_1$ leva em conta a massa da bolinha e a força de Morison e é dada por \begin{align}
 	m_b \ddot{\Upsilon}_1 &= \frac{m_b g}{l}\left(\Upsilon_2 - \Upsilon_1\right) + \rho_{\mathrm{ar}} C_m V_b \ddot{\Upsilon}_1 - \frac{1}{2}\rho_{\textrm{ar}} C_d A_b \dot{\Upsilon}_1 \left|\dot{\Upsilon}_1\right|.\label{upsilon1previa}
 \end{align} 
 
 Isolando $\ddot{\Upsilon}_1$ na Equação \ref{upsilon1previa}, tem-se \begin{align}
 	\ddot{\Upsilon}_1 &= \frac{m_b g}{m'l}\left(\Upsilon_2 - \Upsilon_1\right)  - \frac{1}{2m'}\rho C_d A_b \dot{\Upsilon}_1 \left|\dot{\Upsilon}_1\right|.
 \end{align} 
 
 \paragraph{} Nota-se que $m' = m_b + \rho_{\textrm{ar}} C_m V_b = m_b + m_{fb} \approx m_b$. Assim, assume-se $m' = m_b$ para os cálculos. Anteriormente, foi apresentada a linearização $\tau$ para o termo $\frac{1}{2m}\rho C_d A\left|\dot{\Upsilon}_k\right|$ do cabo. Para o caso da bolinha de isopor, essa constante é diferente e é denotada por $\tau'$, resultando na equação final para $\Upsilon_1$: \begin{align}
 	\ddot{\Upsilon}_1 &= b_1\left(-\Upsilon_1 + \Upsilon_2\right) - \tau'\dot{\Upsilon}_1\label{upsilon1final},
 \end{align} sendo \begin{equation}
 	b_1 = \frac{m_b g}{m'l} = \frac{g}{l}.
 \end{equation}

 \paragraph{} Desta forma, a partir das Equações \ref{upsilon1final} e \ref{upsilon2}-\ref{upsilon6}, pode-se definir o sistema linear em forma matricial \begin{align}
 	\mathbf{\dot{x}} &= \left[\begin{array}{cccccccccccc}
 		0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\
 		0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\
 		0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\
 		0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\
 		0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\
 		0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\
 		-b_1 & b_1 & 0 & 0 & 0 & 0 & -\tau' & 0     & 0 & 0 & 0 & 0\\
 		d_2 & -2b_2  & e_2  & 0  & 0 & 0 &  0    & -\tau & 0 & 0 & 0 & 0\\
 		0 & d_3 & -2b_3  & e_3  & 0  & 0 & 0 &  0    & -\tau & 0 & 0 & 0\\
 		0 & 0 & d_4 & -2b_4  & e_4  & 0  & 0 & 0 &  0    & -\tau & 0 & 0\\
 		0 & 0 & 0 & d_5 & -2b_5  & e_5  & 0  & 0 & 0 &  0    & -\tau & 0\\
 		0 & 0 & 0 & 0 & d_6 & -2b_6  & 0  & 0 & 0 &  0    & 0   &-\tau\\
 	\end{array}\right]\mathbf{x} + \left[\begin{array}{c}
	0\\	0\\	0\\	0\\	0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ e_6
\end{array}
\right]u
 \end{align} que pode ser representado concisamente como \begin{align}
 	\mathbf{\dot{x}} &= \left[\begin{array}{cc}
	\mathbf{0}_{6\times 6} & \mathbf{I}_{6\times 6}\\
	\mathbf{M}_{6\times 6} & \mathbf{L}_{6\times 6}\\
\end{array}\right] \mathbf{x} + \left[\begin{array}{c}
	\mathbf{0}_{11\times 1}\\ e_6\\
\end{array} \right]u.
 \end{align}

 Para o caso de uma discretização com $N$ pontos, tem-se \begin{align}
 	\mathbf{\dot{x}} &= \left[\begin{array}{cc}
	\mathbf{0}_{N\times N} & \mathbf{I}_{N\times N}\\
	\mathbf{M}_{N\times N} & \mathbf{L}_{N\times N}\\
\end{array}\right] \mathbf{x} + \left[\begin{array}{c}
	\mathbf{0}_{2N-1\times 1}\\ e_N\\
\end{array} \right]u,\;\;\\
y &= \left[\begin{array}{cc}
	1 & \textbf{0}_{1\times 2N-1}
\end{array}\right]\textbf{x}.
 \end{align}


\subsection{Estratégia de Redução da ordem do modelo}

\paragraph{} A maior parte da teoria clássica de controle lida com sistemas representados por um pequeno número de variáveis de estado. Portanto, uma forma de aplicar métodos clássicos de controle da literatura para sistemas de parâmetros distribuídos discretos é por meio de uma redução da ordem do modelo \cite{fabricioIFAC}.

\paragraph{} Tal redução do modelo será feita em duas etapas: primeiro, uma transformação modal é aplicada nas equações originais do espaço de estados, resultando em uma nova representação em variáveis modais. Nesta forma, o sistema pode ser visto como um conjunto de subsistemas dissociados em paralelo, cuja influência na saída pode ser calculada individualmente. Então, os subsistemas com os maiores ganhos estáticos são escolhidos para criar um modelo de ordem reduzida \cite{fabricioIFAC}.

\paragraph{} Primeiro, deve-se obter os autovalores do espaço de estados do \textit{riser}. Observa-se que eles são sempre distintos entre si, uma condição suficiente para a diagonalização da matriz do espaço de estados. Assim, calcula-se a matriz modal \textbf{T}, cuja i-ésima coluna é o i-ésimo autovetor do sistema: \begin{align}
	\mathbf{T} &= \left(\;\mathbf{v_1}\;|\;\mathbf{v_2}\;|\;\ldots\;|\;\mathbf{v_{2N}}\;\right)_{1\times 2N}
\end{align}

\paragraph{} A matriz $\mathbf{T}$ provavelmente tem valores complexos. Isso é um problema para a representação em espaço de estados e sua simulação. A solução é criar uma matriz $\mathbf{\tilde{T}}$ que tenha só números reais. Antes de explicar como criá-la, deve-se lembrar que que os autovalores complexos sempre aparecem em pares conjugados, já que a matriz $\mathbf{A}$ só tem valores reais. Quando a primeira coluna de um autovetor de um par complexo conjugado for encontrada, a coluna respectiva de $\mathbf{\tilde{T}}$ será sua parte real. A segunda coluna desse par complexo conjugado será a parte imaginária da coluna de $\mathbf{T}$.


\paragraph{} A matriz $\mathbf{\tilde{T}}$ é utilizada para uma transformação de similaridade no sistema original: \begin{align}
	\mathbf{A_M} &= \mathbf{\tilde{T}}^{-1}\mathbf{A}\mathbf{\tilde{T}},\\
	\mathbf{x_M} &=\mathbf{\tilde{T}}^{-1}\mathbf{x},	\\
	\mathbf{B_M} &= \mathbf{\tilde{T}}^{-1}\mathbf{B},\textrm{ e}\\
	\mathbf{C_M} &=\mathbf{C}\mathbf{\tilde{T}}.
\end{align}


\paragraph{} O sistema transformado, denotado pelo subscrito $\mathbf{M}$, é mais adequado à análise. $\mathbf{A_M}$ é uma matriz diagonal, com seus autovalores explícitos, e permitindo o desacoplamento do sistema original em $N$ subsistemas formados por pares de autovalores reais ou complexo-conjugados. Nota-se que cada subsistema é de ordem 1 ou 2 dependendo se o autovalor é real ou um par complexo conjugado.

\paragraph{} Neste estágio, procura-se determinar quais dos subsistemas são mais adequados para aproximar o modelo original por meio do cálculo do ganho estático de cada um. Este método depende da predominância de uns poucos autovalores na resposta do sistema, já que altas frequências são muito atenuadas pelas forças hidrodinâmicas e pela suavidade da entrada.

\paragraph{} Os subsistemas selecionados são combinados em um modelo reduzido \begin{align}
	\mathbf{\dot{z}} &= \mathbf{A_R}\mathbf{z}+\mathbf{B_R}u\\
	y &= \mathbf{C_R}\mathbf{z}+\mathbf{D_R}u
\end{align} cuja ordem é escolhida considerando o custo-benefício entre a acurácia da dinâmica reduzida e a simplicidade da estrutura de controle exigida. Além disso, o sistema reduzido deve compensar o ganho estático perdido nos autovalores desconsiderados. Isto é feito por meio de uma matriz de transferência direta $\mathbf{D_R}$, que é a diferença dos ganhos dos sistemas original e reduzido: \begin{align}
	\mathbf{D_R}&=\mathbf{C}\mathbf{A^{-1}}\mathbf{B}-\mathbf{C_R}\mathbf{A_R^{-1}}\mathbf{B_R}.
\end{align}


\paragraph{} A matriz de transferência direta $\mathbf{D_R}$ introduz novas dinâmicas: uma saída não-nula que não leva em conta o atraso de propagação da entrada e um ganho em altas frequências. Conforme mostrado por Fortaleza \cite{teseEugenio}, pode-se refinar o modelo reduzido introduzindo um atraso de entrada $\epsilon$ que minimiza a transferência direta e garante dinâmica nula para $t < \epsilon$: \begin{align}
\begin{array}{lll}
	\mathbf{\dot{z}} &=& \mathbf{A_R}\mathbf{z}+\mathbf{B_D}u(t-\epsilon),\\
	y &=& \mathbf{C_R}\mathbf{z}+\mathbf{D_D}u(t-\epsilon) \label{novoModeloReduzido};
\end{array}
\end{align} sendo \begin{align}
	\mathbf{B_D} &= \mathbf{A_M}\left(e^{\epsilon\mathbf{A_M}}\right)\mathbf{A_M^{-1}}\mathbf{B_M}\;\;\mathrm{e}\\
	\mathbf{D_D} &= \mathbf{C_M}\left(e^{\epsilon\mathbf{A_M}} - \mathbf{I}\right)\mathbf{A_M^{-1}}\mathbf{B_M} + \mathbf{D_M}.
\end{align}

\paragraph{} O novo modelo reduzido (\ref{novoModeloReduzido}) é tal que, para uma entrada degrau no instante $t'$, a saída mantém seu valor inicial enquanto $t < t' + \epsilon$. Para $t \ge t' + \epsilon$, ambos os modelos reduzidos produzem a mesma saída. O atraso $\epsilon$ pode ser visto como uma aproximação para o atraso natural de propagação da estrutura.

\section{Controle}
\subsection{Técnicas Simples de Controle}
\paragraph{} Técnicas de controle simples devem ser introduzidas de forma a se compreender o objetivo deste trabalho, que é do posicionamento do \textit{riser} por meio de controle em malha fechada. Primeiramente, apresenta-se o controle em malha aberta, cujo diagrama pode ser observado na Figura \ref{mabertatikz}. A variável $r = r(t)$ é a referência do sistema. Neste tipo de controle, a saída não é realimentada na entrada. Desta forma, este tipo de controle não requer sensores, pois somente dá uma referência de entrada que a planta deve seguir. Caso haja erros para seguir a trajetória, eles não poderão ser compensados e é um controle mais recomendado quando o sistema é preciso e há pouca ou nenhuma perturbação. No entanto, este não é o caso do \textit{riser}, pois o movimento das águas no leito oceânico perturba o tubo, causando erros na posição final desejada. O controle malha aberta foi anteriormente verificado na referência \cite{redytton}.

\tikzstyle{block} = [draw, fill=blue!20, rectangle, 
minimum height=3em, minimum width=6em]
\tikzstyle{sum} = [draw, fill=blue!20, circle, node distance=1cm]
\tikzstyle{input} = [coordinate]
\tikzstyle{output} = [coordinate]
\tikzstyle{pinstyle} = [pin edge={to-,thin,black}]

\begin{figure}[!ht]
	\centering
	% The block diagram code is probably more verbose than necessary
	\begin{tikzpicture}[auto, node distance=2cm,>=latex']
	% We start by placing the blocks
	\node [input, name=input] {};
	\node [block, right of=input] (controller) {Controlador};
	\node [block, right of=controller, pin={[pinstyle]above:Perturbações},
	node distance=3cm] (system) {Planta};
	% We draw an edge between the controller and system block to 
	% calculate the coordinate u. We need it to place the measurement block. 
	\draw [->] (controller) -- node[name=u] {$u$} (system);
	\node [output, right of=system] (output) {};
	
	% Once the nodes are placed, connecting them is easy. 
	\draw [draw,->] (input) -- node {$r$} (controller);
	\draw [->] (system) -- node [name=y] {$y$}(output); 
	\end{tikzpicture}
	\caption{Malha aberta de controle\label{mabertatikz}}
\end{figure}

\paragraph{} Uma forma de se compensar as perturbações do ambiente é realimentando a saída na entrada, calculando a diferença entre a referência e o valor medido. Assim, um valor de erro $e = e(t)$ é obtido e o sistema calcula o sinal $u$ conforme o erro evolui. A Figura \ref{mfechadatikz} mostra um esquema básico deste sistema, evidenciando a presença de uma malha fechada de controle.


\begin{figure}[!ht]
\centering
% The block diagram code is probably more verbose than necessary
\begin{tikzpicture}[auto, node distance=2cm,>=latex']
% We start by placing the blocks
\node [input, name=input] {};
\node [sum, right of=input] (sum) {};
\node [block, right of=sum] (controller) {Controlador};
\node [block, right of=controller, pin={[pinstyle]above:Perturbações},
node distance=3cm] (system) {Planta};
% We draw an edge between the controller and system block to 
% calculate the coordinate u. We need it to place the measurement block. 
\draw [->] (controller) -- node[name=u] {$u$} (system);
\node [output, right of=system] (output) {};
\node [block, below of=u] (measurements) {Medição};

% Once the nodes are placed, connecting them is easy. 
\draw [draw,->] (input) -- node {$r$} (sum);
\draw [->] (sum) -- node {$e$} (controller);
\draw [->] (system) -- node [name=y] {$y$}(output);
\draw [->] (y) |- (measurements);
\draw [->] (measurements) -| node[pos=0.99] {$-$} 
node [near end] {$y_m$} (sum);
\end{tikzpicture}
\caption{Malha fechada de controle\label{mfechadatikz}}
\end{figure}

%TODO Preditor de Smith - Controlador, Atraso e Kalman
\subsection{Controle Discreto no Espaço de Estados}
\paragraph{} Na seção \ref{modelagem}, obtiveram-se equações do sistema contínuo no tempo, mas discretizado espacialmente. A discretização espacial transformou a equação diferencial parcial, um sistema de ordem infinita \cite{fabricioIFAC}, em um sistema em espaço de estados finito. Mais informações sobre o espaço de estados estão disponíveis em \cite{Ogata:2010} e \cite{OgataDiscrete:1995}. 
\paragraph{} Neste trabalho, uma câmera é utilizada para leitura da posição da bolinha, conforme é mostrado na seção \ref{bancada}. A câmera leva entre 20 e 50ms para terminar uma leitura de posição, dependendo das ferramentas utilizadas. Portanto, faz sentido trabalhar de forma discreta. O próximo CLP tem um limite de processamento que deve ser respeitado, daí quanto maior o tempo de amostragem melhor. O tempo de amostragem não pode ser arbitrariamente grande, já que é importante seguir o teorema de Nyquist \cite{Ogata:2010} que requer que a frequência de amostragem seja pelo menos duas vezes a frequência da maior oscilação. Para o presente trabalho, $T_s = 0.1$s já atende esse requerimento. o que economizaria processamento.

\paragraph{} Definido o período de amostragem, o sistema contínuo da Equação \ref{novoModeloReduzido} deve ser convertido para espaço discreto. A função \texttt{c2d} do MATLAB \cite{c2d} faz a conversão para o espaço discreto, bastando fornecer o período de amostragem $T_s$. O modo padrão é a conversão utilizando um segurador de ordem zero \cite{OgataDiscrete:1995}. Uma vez tendo o modelo discreto, deve-se fazer o projeto do controlador, alocando os pólos no plano $z$. Uma referência para este tipo de controle é \cite{OgataDiscrete:1995}.

\paragraph{} O controle que será utilizado será realimentação de estados com um canal integral. O canal integral adiciona um estado a mais no sistema em malha fechada. Considerando um sistema definido pelas matrizes $\mathbf{A}$, $\mathbf{B}$ e $\mathbf{C}$, o sistema aumentado passa ter matrizes $\mathbf{\hat{A}}$ e $\mathbf{\hat{B}}$. O projeto considera essas duas matrizes para a definição dos pólos.

\tikzstyle{block} = [draw, rectangle, 
minimum height=2em, minimum width=2em]
\tikzstyle{sum} = [draw, circle, node distance=1cm]
\tikzstyle{input} = [coordinate]
\tikzstyle{output} = [coordinate]
\tikzstyle{pinstyle} = [pin edge={to-,thin,black}]

\begin{figure}[!ht]
\centering
% The block diagram code is probably more verbose than necessary
\begin{tikzpicture}[auto, node distance=1cm,>=latex']
% We start by placing the blocks
\node [input, name=input] {};
\node [sum, right of=input] (sum) {};
\node [sum, right of=sum] (sum2) {};
\node [output, right of=sum2] (vk) {};
\node [output, right of=vk] (vk2) {};
\node [block, right of=vk2] (Ki) {$K_i$};
\node [block, below of=sum2, right of=sum2] (delay1) {$z^{-1}$};

\node [sum, right of=Ki] (sum3) {};
\node [block, right of=sum3] (B) {$\mathbf{B}$};
\node [sum, right of=B] (sum4) {};
\node [block, right of=sum4] (delay2) {$z^{-1}$};
\node [output, right of=delay2] (xk) {$\mathbf{x}_k$};
\node [block, right of=xk] (C) {$\mathbf{C}$};
\node [block, below of=delay2] (A) {$\mathbf{A}$};
\node [block, below of=delay2, left of=A] (Kp) {$\mathbf{K}_p$};
%\node [block, right of=C] (yk) {};
% We draw an edge between the controller and system block to 
% calculate the coordinate u. We need it to place the measurement block. 

\node [output, right of=C] (yk) {};
\node [block, left of=sum4, below of=Kp] (measurements) {Medição};

% Once the nodes are placed, connecting them is easy. 
%\draw [->] (controller) -- node[name=u] {$u$} (system);
\draw [draw,->] (input) -- node {$r_k$} (sum);
\draw [->] (sum3) -- node {$u_k$} (B);
\draw [->] (C) -- node [name=y] {$y$}(yk);
\draw [->] (y) |- (measurements);
\draw [->] (measurements) -| node[pos=0.99] {$-$} node [near end] {$y_m$} (sum);
\draw [->] (Kp) -| node[pos=0.99] {$-$} (sum3);
\draw [->] (A) -| (sum4);
\draw [-] (delay2) -- node[pos=0.99] {$x_k$} (xk);
\draw [->] (xk) -- (C);
\draw [->] (xk) |- (A);
\draw [->] (xk) |- (Kp);
\draw [->] (sum) -- (sum2);
\draw [->] (sum4) -- (delay2);
\draw [->] (B) -- (sum4);
\draw [->] (Ki) -- (sum3);
\draw [->] (vk2) |- (delay1);
\draw [->] (vk2) -- (Ki);
\draw [-] (sum2) -- (vk2);
%\draw [->] (sum2) -- node[name=vkk] {$v_k$} (Ki);
%\draw [->] (vk) |- (delay1);

\draw [->] (delay1) -| node[pos=0.99] {$-$} node [near end] {$v_{k-1}$} (sum2);

\end{tikzpicture}
\caption{Malha fechada de controle, espaço de estados discreto\label{mfechadatikzEspacoDeEstados}}
\end{figure}

\paragraph{} Considerando a Figura \ref{mfechadatikzEspacoDeEstados}, têm-se as matrizes aumentadas \begin{align}
	\mathbf{\hat{A}} & = \left[\begin{array}{cc}
		\mathbf{A} & \mathbf{B}\\
		\mathbf{0} & \mathbf{0}\\
	\end{array}\right]\;\mathrm{e}\\
	\mathbf{\hat{B}} & = \left[\begin{array}{cc}
		\mathbf{0}\\
		1\\
	\end{array}\right].\\
\end{align}

\paragraph{} O projeto do controlador resume-se a definir o ganho $\mathbf{\hat{K}}$ seguindo a fórmula de Acker, explicada em \cite{OgataDiscrete:1995}, \begin{align}
	\mathbf{\hat{K}} & = \left[0,\; 0,\; 0,\; 0,\; 1\right]\left[\mathbf{\hat{B}},\; \mathbf{\hat{A}}\mathbf{\hat{B}},\; \mathbf{\hat{A}}^2\mathbf{\hat{B}},\; \mathbf{\hat{A}}^3\mathbf{\hat{B}},\; \mathbf{\hat{A}}^4\mathbf{\hat{B}}\right]\phi(\mathbf{\hat{A}}),
\end{align} sendo $\phi(\mathbf{\hat{G}})$ dado por \begin{align}
	\phi(\mathbf{\hat{A}}) &= \mathbf{\hat{A}}^5 + \alpha_1 \mathbf{\hat{A}}^4 + \alpha_2 \mathbf{\hat{A}}^3 + \alpha_3 \mathbf{\hat{A}}^2 + \alpha_4 \mathbf{\hat{A}} + \alpha_5 \mathbf{I},
\end{align} no qual os coeficientes $\alpha_i$ são coeficientes do polinômio característico desejado, tal como \begin{align}
	z^5 + \alpha_1 z^4 + \alpha_2 z^3 + \alpha_3 z^2 + \alpha_4 z + \alpha_5 & =0.
\end{align}

\paragraph{} O MATLAB já tem um comando que permite obter $\mathbf{\hat{K}}$ a partir dos pólos do sistema:\begin{lstlisting}
	Khat = acker(Ahat, Bhat, p);
\end{lstlisting}

\paragraph{} As matrizes aumentadas apresentadas anteriormente consideram uma forma mais simples para obtenção do vetor de ganhos $\mathbf{\hat{K}}$, que deve ser então convertido para um vetor $\mathbf{K}$ que pode ser utilizado no projeto, por meio de \begin{align}
	\mathbf{K} &= \left(\mathbf{\hat{K}}+[\mathbf{0}\;\; 1]\right)\left[\begin{array}{cc}
	\mathbf{A}-\mathbf{I}_n & \mathbf{B}\\
	\mathbf{C}\mathbf{A} & \mathbf{C}\mathbf{B}\\
\end{array}
\right]^{-1}.\label{obterK}
\end{align}

\paragraph{} Na Equação \ref{obterK}, note que $n$ é a ordem da matriz $\mathbf{A}$. O vetor $\mathbf{K}$ contém os ganhos proporcionais, vetor $\mathbf{K}_p$, e o ganho integral, escalar $K_i$, que serão utilizados. Esses elementos podem ser extraídos de $\mathbf{K}$, sendo sua estrutura \begin{align}
	\mathbf{K} & = \left[\begin{array}{c}\mathbf{K}_p\\ K_i\end{array}\right].
\end{align}

\subsection{Preditor de Smith}

\subsection{Filtro de Kalman}

%TODO Terminar rede OPC - e considerar explicar o uso de Python no trabalho.
\section{Bancada\label{bancada}}
A bancada da ponte rolante presente no Laboratório de Automação e Controle está esquematizada na Figura \ref{bancadaEsquematico}. Serão detalhados os componentes desta bancada, de modo a se entender o papel de cada um deles. Observe que no esquemático falta a câmera, que é um sensor que fica de frente para a bancada. 

\begin{figure}[hbt]
\centering
  \includegraphics[width=0.8\textwidth]{figs/fundamentos/bancadaEsquematico}
  \caption{Esquemático da Bancada Utilizada para o Experimento \cite{redytton}\label{bancadaEsquematico}}
\end{figure}

\subsection{Controlador Lógico-Programável}
\begin{figure}[!ht]
  \centering
    \includegraphics[width=0.8\textwidth]{figs/fundamentos/CLP.jpg}
    \caption{CLP com identificação de elementos\label{CLPcomentado}}
    %TODO perguntar se o Rédytton tem o arquivo editável para fazer algumas modificações
\end{figure}

O controlador lógico-programável (CLP - ver Figura \ref{CLPcomentado}) é a espinha dorsal da bancada. Ele é responsável por executar os comandos de controle sobre todos os elementos que estão conectados a ele. A programação do CLP é realizada via computador, mas, uma vez feito o \textit{download} do programa ao CLP, a execução ocorre independentemente do computador, contato que o CLP esteja em modo de execução.

O CLP utilizado é fabricado pela \textit{Allen Bradley}, modelo Logix5560M03SE. Tal modelo possui memória lógica e de dados de 750 KiB, e memória de \textit{I/O} de 494 KiB. Há quatro módulos no \textit{chassis} do controlador:
\begin{itemize}
  \item O próprio controlador;
  \item \textit{SERCOS Interface};
  \item DeviceNET;
  \item EtherNet/IP.
\end{itemize}

Cada um desses módulos será apresentado posteriormente com mais detalhes. Além dos módulos, o controlador ainda possui um \textit{switch} liga/desliga presente no \textit{chassis}. No módulo Logix, há uma chave responsável por alterar o modo de funcionamento do mesmo. As posições possíveis dessa chave são:
\begin{itemize}
  \item RUN (\textit{Run mode});
  \item REM (\textit{Remote mode});
  \item PROG (\textit{Program mode});
\end{itemize}
\begin{comment}
Na prática, o modo REM se divide em dois modos: REM RUN e REM PROG. A maneira de se diferenciar os dois é observar, no módulo Logix, o estado do LED indicador de modo RUN quando a chave estiver na posição REM.

No modo RUN, o controlador apenas roda o programa presente em sua memória; não há qualquer comunicação remota. No modo PROG, o controlador não roda nenhum programa; ele apenas pode receber um novo código. Nos modos REM, há a comunicação com o computador, permitindo verificar valores de variáveis de interesse e alterar, se necessário, o programa a ser rodado pelo controlador. O programa presente no controlador, em modo REM, só roda o código se estiver no modo REM RUN; se for necessário atualizar o programa, o modo deve ser o REM PROG.
\end{comment}

Para fins de melhor utilizar o CLP, será utilizado sempre o modo REM, que pode ser tanto REM RUN ou REM PROG. O modo REM RUM permite a execução do programa; já o modo REM PROG permite a atualização do programa dentro da memória do CLP.
\subsection{SERCOS Interface}

Sercos é um barramento digital de automação que interconecta controladores, \textit{drives}, dispositivos de entrada/saída e atuadores para máquinas e sistemas controlados numericamente. Foi projetado para comunicação serial de alta velocidade de dados em sistemas de tempo real por meio de fibra ótica (Sercos I \& II) ou um cabo Ethernet Industrial (Sercos III). Sercos é um padrão internacional \cite{sercos}.

Num sistema Sercos, todas as malhas que contém servomotores são normalmente fechadas no \textit{drive}. Isto reduz a carga computacional no CLP, permitindo-o sincronizar mais eixos do que conseguiria caso contrário. Além disso, fechar a malha dos servomotores com o \textit{driver} ajuda a reduzir o efeito do atraso de transporte entre o controle de movimento e o \textit{driver} \cite{sercos}.

Nesta bancada, o CLP deve se comunicar com o servomotor (MPL-A310F-SJ22AA) através do \textit{drive} Kinetix (2094-AC05MP5), de forma a movimentar o carrinho segundo uma trajetória planejada ou segundo uma lei de controle em malha fechada executando no CLP. Essa comunicação se dá por um par de fibras óticas full-duplex, conforme se observa na Figura \ref{CLPcomentado}, o que caracteriza uma rede Sercos I ou II.

\subsection{Line Interface Module 2094-AL09}

Este módulo não apareceu no esquemático da Figura \ref{bancadaEsquematico}, mas ele tem a função essencial de interfacear a rede trifásica com o servo \textit{drive}, permitindo o acionamento do motor. Na Figura \ref{LineInterfaceModule}, se observa que há três conjuntos de disjuntores nesse módulo: CB1 \textendash{} liga ou desliga a rede trifásica do \textit{drive}  \textendash{}, CB2 \textendash{} fornece tensão monofásica ao servo \textit{drive} \textendash{} e CB3 \textendash{} liga as duas fontes de tensão DC de 24V \textendash{}, responsáveis pelas entradas e saídas digitais do módulo e alimentação do freio do motor \cite{redytton}.

\begin{figure}[!ht]
  \centering
    \includegraphics[width=0.7\textwidth]{figs/fundamentos/LineInterfaceModule}
    \caption{Line Interface Module modelo 2094-AL09 da Allen Bradley \cite{redytton}\label{LineInterfaceModule}}
\end{figure}

\subsection{Drive Kinetix 6000 da Allen Bradley}

Por meio da Interface Sercos, o CLP comanda o drive que então fornece potência ao motor. O drive controla o servomotor por meio de pulsos PWM. A Figura \ref{kinetix6000} apresenta um Drive Kinetix 6000 da Allen Bradley similar ao utilizado no laboratório. Mais detalhes sobre o funcionamento do drive estão disponíveis em \cite{redytton} e \cite{kinetix6000usermanual}.

\begin{figure}[!ht]
  \centering
    \includegraphics[width=0.3\textwidth]{figs/fundamentos/kinetix6000.jpg}
    \caption{Drive Kinetix 6000 da Allen Bradley\label{kinetix6000}}
\end{figure}

\subsection{Servomotor}

Um servomotor é um atuador rotatório que permite controle preciso da posição angular. O motor consiste de um motor acoplado a um sensor para a realimentação de posição/velocidade. Também é necessário um drive servo para completar o sistema. O \textit{drive} usa o sensor de realimentação para controlar precisamente a posição angular do motor, ou seja, é uma operação em malha fechada. Assim, usando servomotores em malha fechada, tem-se uma alternativa de alto desempenho aos motores de passo e de indução \cite{defServoMotores}.

O servomotor MPL-A310F-SJ22AA da \textit{Allen-Bradley} foi utilizado e está representado na Figura \ref{servomotor}. O mesmo é composto por um motor indutivo de tensão nominal $230V_{\mathrm{ac}}$ e um encoder do tipo StegmanHiperface, que mede posição de forma absoluta e velocidade de forma incremental \cite{redytton}.

\begin{figure}[!ht]
  \centering
    \includegraphics[width=0.3\textwidth]{figs/fundamentos/servomotor}
    \caption{Servomotor modelo MPL-A310F-SJ22AA\label{servomotor}}
\end{figure}

\subsection{Sensores indutivos}
Os sensores indutivos são elementos detectores de presença, particularmente de objetos metálicos. Eles funcionam através da variação de campo magnético ocasionada pela presença do objeto a ser identificado. Tal variação de campo magnético provoca uma variação de corrente dentro do sensor, alterando seu estado.

Na presente bancada, há 6 sensores indutivos da família 871TM, similares ao da Figura \ref{sensorIndutivo}, fabricados pela \textit{Allen-Bradley}. Eles são alimentados com tensão de 24 V, que está dentro dos limites padrão. São sensores feitos de aço, adaptados a ambientes industriais.

\begin{figure}[!ht]
  \centering
    \includegraphics[width=0.3\textwidth]{figs/fundamentos/sensorIndutivo}
    \caption{Sensor indutivo 871T-R8B18 \cite{redytton}\label{sensorIndutivo}}
\end{figure}

A importância desses sensores é enorme. O motivo é que a câmera às vezes falha para obter a posição atual e tem um limite de frequência devido ao processamento interno que ela tem de realizar. Com os sensores indutivos, tem-se um processamento rápido para identificar se o motor está na região próxima dos limites. Assim, a rotina de segurança que trava o motor depende diretamente desses sensores indutivos, como mostra o Anexo \ref{emergencyladder}.

\subsection{Câmera PresencePlus}

A câmera PresencePlus P4 GEO da Banner Engineering foi utilizada no projeto - veja Figura \ref{cameraBanner}. Esta câmera é um sensor robusto utilizado em ambientes industriais com fácil utilização. Sua programação é feita em software próprio da Banner e é visual.

Dentre as capacidades da câmera, nota-se que ela pode capturar até 24 imagens por segundo. No entanto, além da captura das imagens há o processamento das imagens, que pode ser feito na própria câmera ou em um módulo externo da própria Banner, que também consome certo tempo. O programa utilizado no projeto está disponível no Anexo \ref{ballhorzpos}.

\begin{figure}[!ht]
  \centering
    \includegraphics[width=0.3\textwidth]{figs/fundamentos/camera}
    \caption{Câmera da Banner Engineering utilizada no projeto \cite{redytton}\label{cameraBanner}}
\end{figure}

\section{Redes Utilizadas}
\subsection{DeviceNET}
DeviceNET é um protocolo de baixo nível da camada de aplicação, voltado a ambientes industriais \cite{dnetrta} Tal rede suporta comunicação entre dispositivos de baixo nível, como sensores e atuadores, e dispositivos de alto nível, como o computador e o CLP \cite{devicenetrockwell}.Permite uma rápida configuração entre dispositivos a \textit{byte}, suportando tanto dispositivos analógicos quanto digitais \cite{redytton}. Permite velocidades de transmissão de até 500 kbps, sendo bem mais lenta que uma rede Ethernet.

No experimento, a rede DeviceNET é utilizada para a conexão entre o CLP e os sensores indutivos presentes na planta \cite{redytton}.  Para fins de detecção de fim-de-curso, será utilizado o modo digital dos sensores, uma vez que apenas é necessário verificar se o carrinho está na área de detecção do sensor. O módulo responsável pelo gerenciamento da rede DeviceNET é o 1756-DNB.

\begin{comment}
https://en.wikipedia.org/wiki/DeviceNet
https://www.odva.org/Portals/0/Library/Publications_Numbered/PUB00122R1_CIP_Brochure_ENGLISH.pdf
\end{comment}

\subsection{Ethernet/IP}
A rede Ethernet/IP, introduzida em meados de 2001 pela ODVA (\textit{Open DeviceNet Vendor Association}) \cite{eipodva1}, é um tipo de rede Ethernet voltada ao ambiente industrial, seguindo o CIP, assim como o DeviceNET \cite{eiprta}. É uma rede robusta, organizada segundo o modelo OSI de 7 camadas, que permite conexão com dispositivos conectados a redes Ethernet padrão; permite a passagem de dados via pacotes TCP ou UDP; é indicada em aplicações que exigem uma transferência rápida e confiável de dados, principalmente em aplicações de tempo real) \cite{eiprockwell}.

No presente experimento, a rede Ethernet/IP é utilizada para receber dados de inspeção da câmera, notadamente a posição horizontal da bola de isopor presa ao barbante. Além disso, ela é utilizada na transferência de programas entre o computador e o CLP (através do módulo Ethernet 1756-ENBT/A), uma vez que ela provê uma comunicação mais rápida do que o RS-232.

\begin{comment}
https://en.wikipedia.org/wiki/Industrial_Ethernet
https://en.wikipedia.org/wiki/EtherNet/IP
https://www.odva.org/Technology-Standards/EtherNet-IP/Overview
http://www.rtaautomation.com/technologies/ethernetip/
http://www.rockwellautomation.com/global/products-technologies/integrated-architecture/ethernet-ip.page
\end{comment}

%TODO Escrever sobre OPC
\subsection{OPC - \textit{OLE for Process Control}}
A rede OPC, cujo primeira versão foi lançada em 1996, é uma rede voltada ao ambiente industrial. Essa rede é responsável, em termos gerais, pela troca confiável de dados entre o CLP, computadores e outros dispositivos. O objetivo do uso de tal rede é abstrair o protocolo de rede utilizado no CLP (seja ModBus, Profibus, Ethernet/IP, etc.) em uma interface padrão de forma que systemas HMI/SCADA possam se comunicar com um "intermediário" que converte as operações de dados de OPC em operações específicas de dispositivo e vice-versa \cite{OPCFoundation1}. 

Uma das características da rede OPC é permitir a troca de dados entre o CLP e o computador por meio de um sistema \textit{server/client}. No presente projeto, o \textit{server} é disponibilizado pelo \textit{software} RSLinx, enquanto que o cliente é um programa desenvolvido externamente ao CLP. Para esse programa, foi escolhida a linguagem Python; a razão da escolha de tal linguagem foi, além da existência de módulos programados por terceiros para lidar com a rede OPC, o fato de Python ter outros módulos que facilitam a implementação de controladores e ser razoavelmente rápido (por exemplo, Python é mais rápido que o \textit{software} MATLAB).

Para se programar o \textit{client} da rede OPC em Python, foi utilizado o módulo OpenOPC. Esse módulo é bem simples de se utilizar; as funções de trocas de dados OPC são abstraídas de modo a utilizar elementos simples da linguagem, como o uso de dicionários. Além de trabalhar em Windows, Linux e MAC OS X, o módulo OpenOPC faz com que seja possível utilizar elementos de programação funcional, reduzindo o tamanho do programa resultado \cite{OpenOPC}.


\section{Programação do CLP}
\subsection{Visão geral}
Programação, em termos gerais, é aplicada na resolução de problemas. Em particular, a programação de CLPs busca resolver, no âmbito industri;al, problemas relacionados à automação de processos. Essa resolução de problemas segue uma metodologia, de forma a se direcionar o projeto. Antes de se proceder à programação, faz-se necessário seguir os seguintes passos \cite{rockwellAutomation}:
\begin{enumerate}
  \item Descrição do problema;
  \item Detalhamentos e melhoria do processo;
  \item Especificação dos atuadores e sensores da planta;
  \item Elaboração do algoritmo;
  \item Representação gráfica do algoritmo, quando aplicável;
  \item Esquema funcional, quando aplicável;
  \item Seleção dos módulos do controlador;
  \item Programação, utilizando linguagens suportadas.
\end{enumerate}

Ao se programar o CLP, deve-se ter em conta que o controlador executa sempre três ciclos \cite{rockwellAutomation}:
\begin{enumerate}
  \item \textit{Scan} de Entrada: Ciclo em que o controlador recebe todos os dados de seus módulos de entrada;
  \item \textit{Scan} do Programa: Ciclo em que o controlador processa as entradas recebidas e gera as saídas;
  \item \textit{Scan} de Saída: Ciclo em que o controlador envia os dados de saída para os módulos de saída.
\end{enumerate}

Para o presente experimento, entre as várias linguagens disponíveis para CLPs, foram selecionadas duas: uma linguagem gráfica, o \textbf{\textit{ladder}}, e uma linguagem textual, o \textbf{texto estruturado}. Ambas foram selecionadas por serem linguagens muito utilizadas, normalmente rápidas e que ocupam pouca memória, ao contrário de linguagens como SFC (\textit{Sequential Flow Chart}) e FBD (\textit{Function Block Diagram}), que também poderiam ser utilizadas.

\subsection{Linguagem \textit{ladder}}
\subsubsection{Introdução ao \textit{ladder}}
A linguagem \textit{ladder} é uma linguagem de programação gráfica, e uma das primeiras a ser utilizada na programação de CLPs. Seu nome vem do inglês \textit{ladder}, que significa escada; nome dado em razão dos programas, ao serem feitos, assumirem a forma de uma escada, e lidos de cima para baixo (movimento de descida). Essa linguagem foi estruturada de forma a ter uma simbologia semelhante à de um diagrama de conexão de relés, que eram utilizados em indústrias antes do CLP.

Todo programa \textit{ladder} possui duas linhas verticais e, entre elas, uma ou mais linhas horizontais nas quais são especificados os comportamentos do programa. A linguagem possui várias instruções, em sua maioria comuns entre diferentes tipos de CLP. A Tabela \ref{ladder1} mostra as principais instruções utilizadas em \textit{ladder}, utilizando a sintaxe presente no \textit{software} RSLogix5000.

\begin{table}[!ht]
  \centering
  \caption{Principais instruções \textit{ladder} \label{ladder1}}
  \begin{tabularx}{\textwidth}{|>{\bfseries}l|l|X|}
    \hline
    Desenho da Instrução & Nome da Instrução & Descrição \\ \hline
    -( )- & OTE & Atualiza variável booleana de acordo com a condição da linha \\ \hline
    -(L)- & OTL & Atribui valor verdadeiro à variável booleana se a linha for alimentada \\ \hline
    -(U)- & OTU & Atribui valor falso à variável booleana se a linha for alimentada \\ \hline
    -[ ]- & XIC & Examina se a variável possui valor verdadeiro \\ \hline
    -[/]- & XIO & Examina se a variável possui valor falso \\ \hline
  \end{tabularx}
\end{table}

\subsubsection{Instruções específicas}
No presente trabalho, a presença do servomotor exige uma lógica e entradas que não são booleanas, ou seja, que não podem ser tratadas pelos operadores descritos na Tabela \ref{ladder1}. Portanto, faz-se necessário o uso de novas instruções, diretamente relacionadas com o movimento do atuador. Tais instruções são conhecidas, dentro do RSLogix5000, como \textit{Motion Control Instructions}, ou instruções de controle de movimento. A Tabela \ref{ladder2} mostra as instruções desse tipo utilizadas no experimento.

\begin{table}[!ht]
  \centering
  \caption{Principais instruções de controle de movimento em \textit{ladder} \label{ladder2}}
  \begin{tabularx}{\textwidth}{|>{\bfseries}l|l|X|}
    \hline
    Nome da Instrução & Sigla & Função \\ \hline
    \textit{Motion Servo On} & MSO & Inicializa o servomotor, travando a esteira. \\ \hline
    \textit{Motion Axis Jog} & MAJ & Envia comandos de velocidade e sentido de rotação ao motor, executando sua movimentação. \\ \hline
    \textit{Motion Axis Stop} & MAS & Interrompe a movimentação do motor; a esteira permanece travada. \\ \hline
    \textit{Motion Servo Off} & MSF & 
    Desativa o servomotor, destravando a esteira e permitindo a movimentação manual do carrinho.\\ \hline
  \end{tabularx}
\end{table}

As funções descritas pela Tabela \ref{ladder2} lidam com outros tipos de variáveis, como números reais, para a velocidade do motor, e até mesmo estruturas que o \textit{software} RSLogix cria para armazenar informações sobre os eixos e o controle feito pelas instruções. Tais parâmetros podem ser alterados dentro dos blocos das funções. A Figura \ref{motionladder1} mostra um exemplo de tais instruções.

\begin{figure}[!ht]
  \centering
    \includegraphics[width=0.6\textwidth]{figs/fundamentos/motionladder}
    \caption{Exemplo de programa \textit{ladder} com instruções de movimentação.\label{motionladder1}}
\end{figure}

\subsection{Texto Estruturado}
\subsubsection{Visão geral do texto estruturado}
Além de \textit{ladder}, que é uma linguagem gráfica, o CLP utilizado no experimento também suporta uma linguagem puramente textual, o texto estruturado. Essa linguagem é uma linguagem sequencial, que lembra muito linguagens como BASIC, C ou Pascal. Cada comando é executado em sequência, salvo em caso de desvios (estruturas do tipo \textit{if-then-else}) ou repetições (\textit{loops}, estruturas do tipo \textit{while}).

Em relação ao \textit{ladder}, o texto estruturado possui vantagens e desvantagens. A principal vantagem é o fato do texto estruturado se assemelhar às linguagens de programação mais utilizadas; isso torna tal linguagem de fácil aprendizado. Além disso, por ser texto, caso seja necessário editar muitos parâmetros cuja criação seja de fácil automação, um programa auxiliar escrito em linguagens de programação genéricas pode simplificar a geração do texto estruturado. Porém, uma desvantagem do texto em relação ao \textit{ladder} reside nas funções de movimentação, uma vez que, ao contrário do \textit{ladder}, o texto estruturado não dá uma indicação clara associando um valor e a variável que ele representa, além da ordem dos parâmetros. Isso torna o uso de funções como MAJ (vide Tabela \ref{ladder2}) um pouco mais complicado em texto estruturado.

\subsubsection{Instruções de movimentação do motor para o texto estruturado}
Assim como o \textit{ladder}, o texto estruturado permite o uso das funções descritas na Tabela \ref{ladder2}. A sintaxe de uso dessas funções lembra muito a sintaxe da linguagem C, com o nome da função e uma lista de parâmetros válidos separados por vírgulas. A seguir, um exemplo de uso:
 
\begin{lstlisting}
/**
* MSO: ativa o servo cujo eixo eh descrito
* por drive_axis; informacoes de controle
* sao gravadas em MSO_1
*/
  MSO(drive_axis,MSO_1);
/* Atribui o valor 0.0 ao primeiro elemento do array speed */
  speed[0] := 0.0; 
/* Atribui 1 para dataInitialized */
  dataInitialized := 1;
\end{lstlisting}

Nota-se que o código apresentado, a menos da operação de atribuição, possui uma sintaxe muito semelhante à de C. A função MSO acima recebe dois parâmetros, assim como em \textit{ladder}; porém, a única indicação de como os parâmetros se comportam é a ordem com que eles são colocados; no caso de MSO, o 1º parâmetro é o eixo que será inicializado, e o 2º parâmetro é uma \textit{tag} que guarda as informações de controle executadas por MSO.


\section{Parâmetros para gerar trajetórias}

\paragraph{}Fabrício et al \cite{fabricioIFAC} desenvolveram um método para gerar trajetórias \textit{offline} (controle malha aberta) assim como \textit{online} (controle malha fechada). Para se utilizar do método, é necessário ter parâmetros do sistema. Se fosse necessário simular ou controlar o sistema real, utilizariam-se os dados da Tabela \ref{escalaReal}, conforme cita Rédytton \cite{redytton}.

\begin{table}[!ht]
\parbox{.45\linewidth}{
\centering
\caption{Dados para simulação em escala real\label{escalaReal} \cite{redytton}}
	\begin{tabular}{|c|c|}
	\hline
		\multicolumn{2}{|c|}{\textbf{Dados do Riser}}\\ \hline
		Diâmetro externo & $0.55\mathrm{m}$\\ \hline
		Diâmetro interno & $0.5\mathrm{m}$ \\ \hline
		Comprimento & $2000\mathrm{m}$ \\ \hline
		Módulo de Elasticidade & $200 \mathrm{GPa}$\\ \hline
		Densidade &  $7860\mathrm{kg}/\mathrm{m}^3$\\ \hline
		\multicolumn{2}{|c|}{\textbf{Dados do fluido (Água)}}\\ \hline
		Densidade do fluido &  $1000\mathrm{kg}/\mathrm{m}^3$\\ \hline
		Viscosidade dinâmica & $10^3 \mathrm{Pa}\cdot \mathrm{s}$ \\ \hline
	\end{tabular}
}
\hfill
\parbox{.45\linewidth}{
	\caption{Dados para simulação em escala laboratorial\label{escalaLaboratorial}}
	\centering
	\begin{tabular}{|c|c|}
		\hline
			\multicolumn{2}{|c|}{\textbf{Dados da Massa na Ponta - Isopor}} \\ \hline
			Diâmetro Externo & $30.6\mathrm{mm}$\\ \hline
			Densidade & $10\mathrm{kg}/\mathrm{m}^3$ \\ \hline
			\multicolumn{2}{|c|}{\textbf{Dados do Riser (Barbante)}}\\ \hline
			Diâmetro externo & $2\mathrm{mm}$\\ \hline
			Diâmetro interno & $0\mathrm{mm}$ \\ \hline
			Comprimento & $82\mathrm{cm}$ \\ \hline
			Módulo de Elasticidade & $2.1 \mathrm{MPa}$\\ \hline
			Densidade &  $191\mathrm{kg}/\mathrm{m}^3$\\ \hline
			\multicolumn{2}{|c|}{\textbf{Dados do fluido (Ar)}}\\ \hline
			Densidade do fluido &  $1.2754\mathrm{kg}/\mathrm{m}^3$\\ \hline
			Viscosidade dinâmica & $17.2\cdot 10^6 \mathrm{Pa}\cdot \mathrm{s}$ \\ \hline
		\end{tabular}
}

\end{table}

\paragraph{}Como é importante se validar o sistema, mas nem sempre isso é possível em escala real devido ao altíssimo custo e aos riscos envolvidos, é necessário um conjunto equivalente de parâmetros tais que permita validar o sistema em escala laboratorial. O \textit{riser} é representado por um barbante e a água é trocada pelo ar. Uma massa na ponta foi adicionada e os dados resultantes estão na Tabela \ref{escalaLaboratorial}.

%\begin{table}[!ht]
%\centering
%\caption{Dados para simulação em escala laboratorial\label{escalaLaboratorial}}
%	\begin{tabular}{|c|c|}
%	\hline
%		\multicolumn{2}{|c|}{\textbf{Dados da Massa na Ponta - Isopor}} \\ \hline
%		Diâmetro Externo & $30.6\mathrm{mm}$\\ \hline
%		Densidade & $10\mathrm{kg}/\mathrm{m}^3$ \\ \hline
%		\multicolumn{2}{|c|}{\textbf{Dados do Riser (Barbante)}}\\ \hline
%		Diâmetro externo & $2\mathrm{mm}$\\ \hline
%		Diâmetro interno & $0\mathrm{mm}$ \\ \hline
%		Comprimento & $82\mathrm{cm}$ \\ \hline
%		Módulo de Elasticidade & $2.1 \mathrm{MPa}$\\ \hline
%		Densidade &  $191\mathrm{kg}/\mathrm{m}^3$\\ \hline
%		\multicolumn{2}{|c|}{\textbf{Dados do fluido (Ar)}}\\ \hline
%		Densidade do fluido &  $1.2754\mathrm{kg}/\mathrm{m}^3$\\ \hline
%		Viscosidade dinâmica & $17.2\cdot 10^6 \mathrm{Pa}\cdot \mathrm{s}$ \\ \hline
%	\end{tabular}
%\end{table}
